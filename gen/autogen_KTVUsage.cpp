#include <stdio.h>
#include "KTVMain.h" 
void KTVMain::Usage(void)
{
	printf("NAME\n");
	printf("    tless - Quick Viewer for text files of tabular data\n");
	printf("\n");
	printf("SYNOPSIS\n");
	printf("    tless [-f inputfile] [options] [-X \"Key Commands\"]\n");
	printf("\n");
	printf("DESCRIPTION\n");
	printf("    Tless is a utility to quickly view tabular text data. It was inspired by\n");
	printf("    \'less\' and acts in a similar capacity for tables. To this end, it offers\n");
	printf("    several essential features.\n");
	printf("\n");
	printf("    Columns: Tless is aware of the concept of a table \"column\" and operates\n");
	printf("    in two dimensions instead of just one. Accordingly, it allows convenient\n");
	printf("    movement and searches using both rows and columns.\n");
	printf("\n");
	printf("    Parsing: Rows are parsed on the fly in a customizable manner. The input\n");
	printf("    may be delimited, fixed width, or csv.\n");
	printf("\n");
	printf("    Synchronized Scrolling: Rows and columns may be frozen and unfrozen\n");
	printf("    dynamically. Tless performs synchronized scrolling with these (frozen\n");
	printf("    columns only scroll vertically and frozen rows only scroll\n");
	printf("    horizontally). This allows a user to scan through a large file of data,\n");
	printf("    both horizontally and vertically, without losing sight of any header\n");
	printf("    rows or index columns. Because the frozen rows and columns need not be\n");
	printf("    consecutive, Tless offers more flexibility than a typical split-screen\n");
	printf("    application.\n");
	printf("\n");
	printf("    Lightweight: Tless examines a file locally and uses a caching mechanism.\n");
	printf("    Like \'less\', it can be used to view very large files (in both\n");
	printf("    directions) with minimal start-up time, performance loss, or memory\n");
	printf("    foot-print. It uses curses and is a terminal application for both\n");
	printf("    portability and speed.\n");
	printf("\n");
	printf("\n");
	printf("    Note that tless is a viewing utility. Although it provides basic search\n");
	printf("    functionality, it is not a spreadsheet or database and allows no\n");
	printf("    editing, calculation, or DB style queries. It can be thought of as a\n");
	printf("    lightweight two dimensional data viewer.\n");
	printf("\n");
	printf("SCREEN LAYOUT\n");
	printf("    The screen is broken into several portions, some of which may not be\n");
	printf("    visible at any given time.\n");
	printf("\n");
	printf("    Row Index: The leftmost column displays the row number in the file. This\n");
	printf("    may be turned on or off dynamically.\n");
	printf("    Frozen Columns: Next from the left are any frozen columns in the order\n");
	printf("    in which they were frozen by the user. These only scroll vertically and\n");
	printf("    may be added or removed dynamically.\n");
	printf("    Column Index: The topmost row displays the column numbers. This may be\n");
	printf("    turned on or off dynamically.\n");
	printf("    Frozen Rows: Next down are any frozen rows in the order in which they\n");
	printf("    were frozen by the user. These only scroll horizontally and may be added\n");
	printf("    or removed dynamically.\n");
	printf("    Message Line: The bottom row is for commands and messages.\n");
	printf("    Active Region: The remainder of the columns and rows are \"active\" and\n");
	printf("    scroll both horizontally and vertically. This is a window into the file.\n");
	printf("    Frozen Cells: Note that in the upper left region, if both rows and\n");
	printf("    columns are frozen there will be an overlap which doesn\'t scroll in\n");
	printf("    either direction.\n");
	printf("\n");
	printf("      1= rowidx   3= colidx  5= msgbar   6= active\n");
	printf("      2= frozencols  4= frozenrows   7= frozenboth\n");
	printf("     ...............................................\n");
	printf("     .   3333|3333#3333|3333|3333|3333|3333|3333|33.\n");
	printf("     . 1 7777|7777#4444|4444|4444|4444|4444|4444|44.\n");
	printf("     . 1 2222|2222#####|####|####|####|####|####|##.\n");
	printf("     . 1 2222|2222#6666|6666|6666|6666|6666|6666|66.\n");
	printf("     . 1 2222|2222#6666|6666|6666|6666|6666|6666|66.\n");
	printf("     . 1 2222|2222#6666|6666|6666|6666|6666|6666|66.\n");
	printf("     . 1 2222|2222#6666|6666|6666|6666|6666|6666|66.\n");
	printf("     . 1 2222|2222#6666|6666|6666|6666|6666|6666|66.\n");
	printf("     . 1 2222|2222#6666|6666|6666|6666|6666|6666|66.\n");
	printf("     . 1 2222|2222#6666|6666|6666|6666|6666|6666|66.\n");
	printf("     . 1 2222|2222#6666|6666|6666|6666|6666|6666|66.\n");
	printf("     . 1 2222|2222#6666|6666|6666|6666|6666|6666|66.\n");
	printf("     .555555555555555555555555555555555555555555555.\n");
	printf("     ...............................................\n");
	printf("\n");
	printf("OPTIONS\n");
	printf("    Note that in some cases the order of options makes a difference. In\n");
	printf("    particular, any default justification should be set before fixed columns\n");
	printf("    are specified. Also, some options only are valid in the context of\n");
	printf("    others. Sometimes invalid options are ignored, but if ambiguous or\n");
	printf("    indicative of user error they may cause the program to exit.\n");
	printf("\n");
	printf("  General\n");
	printf("    \"-h --help\"\n");
	printf("         Display usage information.\n");
	printf("\n");
	printf("    \"-v --version\"\n");
	printf("         Display version number.\n");
	printf("\n");
	printf("    \"-f --file filename\"\n");
	printf("         Specify an input file. At this time, reading from stdin is not\n");
	printf("         supported.\n");
	printf("\n");
	printf("    \"-z --cache n\"\n");
	printf("         Specify a cache size. The maximal cache size will be 3x this\n");
	printf("         because front and end caches are also used. DEFAULT=10000.\n");
	printf("\n");
	printf("    \"-X --exec \"cmds\"\"\n");
	printf("         Execute a series of key commands once initialized. The commands are\n");
	printf("         space delimited and each has either the form \'c\' or \'c:arg:arg:...\'\n");
	printf("         where c is the key for the command and any arguments are those that\n");
	printf("         would be typed after them.\n");
	printf("\n");
	printf("  Parsing\n");
	printf("    Only one of --delim, --sdelim, --csv, or --fixed may be used.\n");
	printf("\n");
	printf("    WARNING: If escaped chars like \\t appear in the argument to --delim or\n");
	printf("    --sdelim then one must be wary of the shell. For example, in bash, one\n");
	printf("    would write --sdelim $\'\\t \' to delimit with tab and space.\n");
	printf("\n");
	printf("    \"-d --delim string\"\n");
	printf("    \"-s --sdelim string\"\n");
	printf("         The file will be parsed using the specified characters as\n");
	printf("         delimiters. For --delim, Adjacent delimiters are merged while for\n");
	printf("         --sdelim they are not. DEFAULT= tab and space.\n");
	printf("\n");
	printf("    \"-t\" Add a tab to the delimiter string. Some shell scripts make it a\n");
	printf("         huge pain to pass a tab to the program. If that is the case, this\n");
	printf("         may be used instead. It adds to the string so other characters may\n");
	printf("         be included in the -d or -s options as well. To parse only with\n");
	printf("         tabs, use -s \'\' -t or something similar. Note that -t implies -d if\n");
	printf("         no -d or -s option is explicitly specified.\n");
	printf("\n");
	printf("    \"-c --csv\"\n");
	printf("         The file will be parsed according to the csv specification. NOTE:\n");
	printf("         At present, this is a simplified parser. It does not allow for\n");
	printf("         arbitrary csv files. It allows \"\" or non-\"\" around field, and\n");
	printf("         allows ,\'s inside of \"\" but nothing more complex than this.\n");
	printf("\n");
	printf("    \"-x --fixed wid1:wid2:wid3:...\"\n");
	printf("         The file will be parsed using the specified fixed column widths.\n");
	printf("\n");
	printf("    \"-l --ignoreleading on/off\"\n");
	printf("         Ignore leading delimiters. This eliminates misalignments due to\n");
	printf("         some rows starting on a delimiter and some not. DEFAULT=on.\n");
	printf("\n");
	printf("    \"-y --doseol\"\n");
	printf("         Assume DOS-style end of line (\'\\r\').\n");
	printf("\n");
	printf("    \"-e --eol char\"\n");
	printf("         Assume this specific char marks the end of line. If 0 then either\n");
	printf("         $\\n$ or $\\r$ will match. Note that null always matches and that\n");
	printf("         adjacent eols yield separate lines and are not merged. DEFAULT= 0\n");
	printf("         (\'\\n\' or \'\\r\').\n");
	printf("\n");
	printf("    \"-M --maxcols n\"\n");
	printf("         Specify a maximum number of columns to parse and display. Any\n");
	printf("         additional columns are ignored.\n");
	printf("\n");
	printf("    \"-Q --removequotes\"\n");
	printf("         Strip outer double-quotes (\"\") if they are present for each field.\n");
	printf("         The quotes are only stripped from a field if they appear as a pair.\n");
	printf("\n");
	printf("    \"-k --skip n\"\n");
	printf("         Skip the first n rows of the file for all purposes.\n");
	printf("\n");
	printf("    \"-m --allowexpansion\"\n");
	printf("         Allow the file to expand while in use. The reason this must be\n");
	printf("         specified is that a file without a terminal eol would lose the last\n");
	printf("         line if we allow expansion (because we must hold off processing any\n");
	printf("         line without an eol until it is complete).\n");
	printf("\n");
	printf("  Display\n");
	printf("    \"-a --aligntofirst\"\n");
	printf("         Use the specified delimiters to set the column widths to those in\n");
	printf("         the first row (or first non-skipped row). Only for use with --delim\n");
	printf("         and --sdelim. Note that this may lead to visually unappealing\n");
	printf("         results if the first row is a header with headings that are smaller\n");
	printf("         than the data entries below them (but this may always be corrected\n");
	printf("         using the key commands \"+\", \"-\", and \"W\").\n");
	printf("\n");
	printf("    \"-w --defwidth n\"\n");
	printf("         Set the column width for all columns to n. DEFAULT=12.\n");
	printf("\n");
	printf("    \"-G --grid [c]\"\n");
	printf("         Display separators between columns. If \'c\' is specified, use that\n");
	printf("         character as the separator. Otherwise, \"|\" is the default. Note\n");
	printf("         that the grid may be turned on and off dynamically as well (see key\n");
	printf("         command \"x\").\n");
	printf("\n");
	printf("    \"-S --seps [c]\"\n");
	printf("         Display separators between the frozen rows/cols and the active\n");
	printf("         portion of the screen. If \'c\' is specified, use that character as\n");
	printf("         the separator. Otherwise, the default is \"#\". The separators may be\n");
	printf("         toggled on and off dynamically as well (see key command \"y\").\n");
	printf("\n");
	printf("    \"-R --rowindex on/off/n\"\n");
	printf("         Activate or deactivate the leftmost column, which is a row index.\n");
	printf("         If the argument is a number instead of on/off, use that as the\n");
	printf("         width. Otherwise, the default width is 6 characters (followed by a\n");
	printf("         space). This may be toggled on and off dynamically using the \"P\"\n");
	printf("         key command. DEFAULT= 6 (on).\n");
	printf("\n");
	printf("    \"-C --colindex on/off\"\n");
	printf("         Activate or deactivate the topmost row, which is a column index.\n");
	printf("         This may be toggled on and off dynamically using the \"V\" key\n");
	printf("         command. DEFAULT=on.\n");
	printf("\n");
	printf("    \"-j --justify right/left\"\n");
	printf("         Set the default justification for all columns. This may be changed\n");
	printf("         dynamically using the \"j\" and \"J\" key commands. DEFAULT=right.\n");
	printf("\n");
	printf("    \"-F --filler char\"\n");
	printf("         Specify a filler character for any empty space on the screen.\n");
	printf("         DEFAULT= \" \" (white space).\n");
	printf("\n");
	printf("KEYBOARD COMMANDS\n");
	printf("    The following keys perform actions while running. Those with [foo] after\n");
	printf("    them indicate a required argument (as opposed to the option section\n");
	printf("    where it indicated an optional argument). This is input on the command\n");
	printf("    line (the bottom line of the terminal) followed by enter. Note that the\n");
	printf("    number of columns may grow if the document width changes). The movement\n");
	printf("    commands only affect the active region.\n");
	printf("\n");
	printf("    Searches may either be ordinary (simple text matching) or regexps. The\n");
	printf("    type is autodetected depending on whether the string is surround by a //\n");
	printf("    pair. Note that for searches, the matching text may not be visible on\n");
	printf("    the screen if the cell is too narrow to display it. Using the \'v\'\n");
	printf("    command should allow full visibility. Regardless, the matching cell row\n");
	printf("    and col are displayed in the message bar. Also note that regexps are\n");
	printf("    compared per cell. That is, the cell itself is viewed as \'line\' rather\n");
	printf("    than the row as a whole. Typically, the active window aligns to the next\n");
	printf("    search result in the upper left corner. However, it may not do so (or\n");
	printf("    appear to do so) if the result appears in the frozen part of the screen.\n");
	printf("    Hidden columns are not searched.\n");
	printf("\n");
	printf("    \"h\" Print usage information and exit.\n");
	printf("    \"l,r\" Move left or right one column.\n");
	printf("    \"a,e\" Move to the far left or right.\n");
	printf("    \"<,> \" Move to the left or right one screen.\n");
	printf("    \"y,k\" Move up one line.\n");
	printf("    \"j\" Move down one line.\n");
	printf("    \"b,u\" Move up one screen.\n");
	printf("    \"f,d,spc\" Move down one screen.\n");
	printf("    \"g,G\" Move to the top or bottom of the document (note that G may take a\n");
	printf("    while for a large file).\n");
	printf("    \"C [n]\" Toggle whether column n is frozen. Frozen columns appear on the\n");
	printf("    left in the order in which they were frozen.\n");
	printf("    \"C [.]\" Unfreeze all columns.\n");
	printf("    \"C [n]\" Toggle whether row n is frozen. Row n must be visible (or in the\n");
	printf("    cache) in order to freeze it (but any frozen row may be unfrozen).\n");
	printf("    Frozen rows appear on the top in the order in which they were frozen.\n");
	printf("    \"R [.]\" Unfreeze all rows.\n");
	printf("    \"s or / [foo]\" Row-wise search. Places top-left corner at search result\n");
	printf("    and displays the result on the message line. The search is forward and\n");
	printf("    down from the upper left active cell (or the previous result). If foo is\n");
	printf("    of the form /bar/ then it is interpreted as a regexp. Otherwise it is\n");
	printf("    treated like an ordinary string to match.\n");
	printf("    \"S or ? [foo]\" Column-wise search. Places top-left corner at search\n");
	printf("    result and displays the result on the message line. The search is down\n");
	printf("    and forward from the upper left active cell (or the previous result). If\n");
	printf("    foo is of the form /bar/ then it is interpreted as a regexp. Otherwise\n");
	printf("    it is treated like an ordinary string to match.\n");
	printf("    \"n,p\" Next, previous search result for last search. \"p\" may also be used\n");
	printf("    to search backwards.\n");
	printf("    \"v [row:col]\" Display the contents of the specified cell (on screen) in\n");
	printf("    the message area. Useful when a cell is too small to fully display its\n");
	printf("    contents.\n");
	printf("    \"H [n]\" Toggle hidden status of column n. Hidden columns are not shown\n");
	printf("    or searched and may or may not be frozen.\n");
	printf("    \"H [.]\" Unhide all columns.\n");
	printf("    \"+ [n]\" Expand width of column n by 1.\n");
	printf("    \"- [n]\" Shrink width of column n by 1. The width cannot drop below 1 (to\n");
	printf("    hide the column, use \'H\').\n");
	printf("    \"+ [.]\" Expand width of all columns by 1.\n");
	printf("    \"- [.]\" Shrink width of all columns by 1. The width of any column cannot\n");
	printf("    drop below 1.\n");
	printf("    \"W [n:w]\" Specify width of column n as w.\n");
	printf("    \"W [.:w]\" Specify width of all columns as w.\n");
	printf("    \"m [c]\" Mark position and label it with letter c.\n");
	printf("    \"\' [c]\" Return to the position labelled with letter c.\n");
	printf("    \"^ [n]\" Justify column n to left.\n");
	printf("    \"$ [n]\" Justify column n to right.\n");
	printf("    \"^ [.]\" Justify all columns to left.\n");
	printf("    \"$ [.]\" Justify all columns to right.\n");
	printf("    \"x\" Toggle grid.\n");
	printf("    \"z\" Toggle frozen section separators.\n");
	printf("    \"P\" Toggle row index column.\n");
	printf("    \"V\" Toggle column index row.\n");
	printf("    \"L [row:col]\" Move the upper left corner of the active region to the\n");
	printf("    specified row and column. If they are frozen or hidden, find a nearby\n");
	printf("    substitute.\n");
	printf("    \"q\" Quit.\n");
	printf("    \"Y\" Resize the screen to fit the terminal. This should be done\n");
	printf("    automatically when the terminal is resized, but a command is provided in\n");
	printf("    case a manual repaint is needed.\n");
	printf("    \"F\" Clear EOF info so that new lines added afterward can be read.\n");
	printf("\n");
	printf("    Note that the \"G\" and \"S\" commands necessarily involve a seek to the end\n");
	printf("    of the file and will be expensive for large files. Also, the commands\n");
	printf("    \"s\", \"n\", \"p\", and \"L\" may prove expensive depending on the details of\n");
	printf("    the file and request.\n");
	printf("\n");
	printf("Key Summary\n");
	printf("     Action        Cols                 Rows\n");
	printf("     -----------------------------------------------\n");
	printf("     Move       a < l r > e    g b|u y|k j f|d|spc G\n");
	printf("     (Un)Freeze   C [n|.]              R [n|.]      \n");
	printf("     (Un)Hide   H [n|.]                             \n");
	printf("     Search     S|? [str|/str/]      s|/ [str|/str/]\n");
	printf("     -----------------------------------------------\n");
	printf("     Col width:  +/-[n|.]   W[n:m]    W[.:m]        \n");
	printf("     Cell just (lft|rgt):   ^|$ [n|.]               \n");
	printf("     Mark set|recover:      m|\' [c]                 \n");
	printf("     Cell: L[row:col] (goto) v[row:col] (disp)      \n");
	printf("     General: q(quit) h(hlp) Y(draw) F(rsteof)      \n");
	printf("     Disp: x(grid) z(seps) P(rowidx) V(colidx)      \n");
	printf("     -----------------------------------------------\n");
	printf("\n");
	printf("EXAMPLES\n");
	printf("    Parse csv file: tless -c -f foo.csv\n");
	printf("\n");
	printf("    Parse tab-delimited: cat foo.txt | tless -s \"\\\\t\" -a\n");
	printf("\n");
	printf("    Parse white-space separated columns: cat foo.txt | tless -d \" \\\\t\" -a\n");
	printf("\n");
	printf("    Parse left-justified fixed width columns: tless -f foo.txt -j left\n");
	printf("    -x:10:20:30:40:50:65\n");
	printf("\n");
	printf("    Parse \':\' separated columns that are all the same width: tless -f\n");
	printf("    foo.txt -d \":\" -w 15\n");
	printf("\n");
	printf("    A simple setup tless -f foo.txt -X \"x y C:0 R:0 L:24:10\"\n");
	printf("\n");
	printf("EXIT STATUS\n");
	printf("    tless returns a zero exit status. It restores the terminal on exit.\n");
	printf("\n");
	printf("AUTHOR\n");
	printf("    Ken Halpern\n");
	printf("\n");
	printf("LICENSE\n");
	printf("    tless may be used under the terms of the following BSD license.\n");
	printf("\n");
	printf("    Copyright (c) 2011, Ken Halpern\n");
	printf("\n");
	printf("    All rights reserved.\n");
	printf("\n");
	printf("    Redistribution and use in source and binary forms, with or without\n");
	printf("    modification, are permitted provided that the following conditions are\n");
	printf("    met:\n");
	printf("\n");
	printf("    Redistributions of source code must retain the above copyright notice,\n");
	printf("    this list of conditions and the following disclaimer.\n");
	printf("\n");
	printf("    Redistributions in binary form must reproduce the above copyright\n");
	printf("    notice, this list of conditions and the following disclaimer in the\n");
	printf("    documentation and/or other materials provided with the distribution.\n");
	printf("\n");
	printf("    Neither the name of the author nor the names of any contributors may be\n");
	printf("    used to endorse or promote products derived from this software without\n");
	printf("    specific prior written permission.\n");
	printf("\n");
	printf("    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n");
	printf("    IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n");
	printf("    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n");
	printf("    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n");
	printf("    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n");
	printf("    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n");
	printf("    TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n");
	printf("    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n");
	printf("    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n");
	printf("    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n");
	printf("    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n");
	printf("\n");
	printf("SEE ALSO\n");
	printf("    less(1), troff(1)\n");
	printf("\n");
}


